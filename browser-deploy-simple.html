<!DOCTYPE html>
<html>
<head>
    <title>Supabase Edge Function Deployer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .container { background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 10px 0; }
        .function-code { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 5px; font-family: 'Courier New', monospace; white-space: pre-wrap; max-height: 300px; overflow-y: auto; }
        button { background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #059669; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        input[type="password"] { width: 400px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .log { background: #000; color: #0f0; padding: 10px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; max-height: 200px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>üöÄ Supabase Edge Function Deployer</h1>
    
    <div class="container">
        <h3>Step 1: Get Access Token</h3>
        <p>1. Go to <a href="https://supabase.com/dashboard/account/tokens" target="_blank">https://supabase.com/dashboard/account/tokens</a></p>
        <p>2. Create a new token with "All" permissions</p>
        <p>3. Copy and paste it below:</p>
        <input type="password" id="accessToken" placeholder="Your Supabase Access Token" />
        <button onclick="validateToken()">Validate Token</button>
        <div id="tokenStatus"></div>
    </div>

    <div class="container">
        <h3>Step 2: Deploy Functions</h3>
        <div style="display: flex; gap: 10px; margin: 10px 0;">
            <button onclick="deployFunction('dish-search')" id="deployDishSearch" disabled>Deploy dish-search</button>
            <button onclick="deployFunction('get-menu-data')" id="deployGetMenu" disabled>Deploy get-menu-data</button>
            <button onclick="deployFunction('geoapify-proxy')" id="deployGeoapify" disabled>Deploy geoapify-proxy</button>
        </div>
        <button onclick="deployAllFunctions()" id="deployAll" disabled style="background: #f59e0b;">Deploy All Functions</button>
    </div>

    <div class="container">
        <h3>üìã Deployment Log</h3>
        <div id="deploymentLog" class="log">Ready to deploy...\n</div>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div class="container">
        <h3>üîç Function Preview</h3>
        <select id="functionSelect" onchange="showFunctionCode()">
            <option value="">Select a function to preview</option>
            <option value="dish-search">dish-search</option>
            <option value="get-menu-data">get-menu-data</option>
            <option value="geoapify-proxy">geoapify-proxy</option>
        </select>
        <div id="functionPreview" class="function-code" style="display: none;"></div>
    </div>

<script>
const PROJECT_REF = 'cjznbkcurzotvusorjec';
let accessToken = '';

// Function codes embedded directly
const FUNCTIONS = {
    'dish-search': `// supabase/functions/dish-search/index.ts  
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface RawDishData {
  id: string;
  name: string;
  description?: string;
  restaurants?: {
    id: string;
    name: string;
    latitude?: number;
    longitude?: number;
  };
  dish_ratings?: Array<{
    rating: number;
    user_id: string;
  }>;
  [key: string]: unknown;
}
import { checkCategorySearch, getAllRelatedTerms, getCategoryTerms, getExclusionTerms } from '../_shared/search-logic.ts';


// CORS headers for browser access  
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
}


// --- TYPE DEFINITIONS ---  
/* interface DishSearchResultWithRestaurant {
  id: string;
  restaurant_id: string;
  name: string;
  description: string | null;
  category: string | null;
  is_active: boolean;
  created_by: string | null;
  verified_by_restaurant: boolean;
  total_ratings: number;
  average_rating: number;
  created_at: string;
  updated_at: string;
  restaurant: {
    id: string;
    name: string;
    latitude?: number | null;
    longitude?: number | null;
  };
  // other relations
} */


const supabaseAdminClient = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

const securityCheck = async (req: Request, supabaseUrl: string, supabaseAnonKey: string): Promise<{ user: unknown; error: string | null }> => {
  const authHeader = req.headers.get('Authorization');
  if (!authHeader) {
    return { user: null, error: 'Missing Authorization header.' };
  }
   
  try {
    const userClient = createClient(supabaseUrl, supabaseAnonKey, {
      global: { headers: { Authorization: authHeader } },
    });
     
    const { data: { user } } = await userClient.auth.getUser();
    if (!user) {
      return { user: null, error: 'Invalid token.' };
    }

    return { user, error: null };

  } catch {
      return { user: null, error: 'An error occurred during authentication.' };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // --- SECURITY CHECK ---  
    const { error: authError } = await securityCheck(req, Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_ANON_KEY')!);
    if (authError) {
      return new Response(JSON.stringify({ error: authError }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const { searchTerm, minRating } = await req.json();


    // --- THE FIX: This function is now much lighter ---
    // It calculates stats from a minimal ratings payload and returns empty arrays for heavy data.
    const processRawDishes = (rawData: RawDishData[]) => {
      return (rawData || []).map((d: RawDishData) => {
        if (!d || !d.restaurants || !d.id) return null;
         
        // Destructure to separate the lightweight ratings from the main dish and restaurant data
        const { dish_ratings, restaurants, ...dishData } = d;


        // Calculate stats from the minimal ratings payload: [{rating: number}, ...]
        const ratings = dish_ratings || [];
        const totalRatings = ratings.length;
        const averageRating = totalRatings > 0
          ? ratings.reduce((sum: number, r: { rating: number; }) => sum + r.rating, 0) / totalRatings
          : 0;


        // Return a lightweight object. Comments and photos are not needed for discovery.
        return {
          ...dishData,
          restaurant: restaurants,
          ratings: [], // Send empty array to client to save bandwidth
          comments: [], // Send empty array
          photos: [], // Send empty array
          total_ratings: totalRatings, // Use freshly calculated value
          average_rating: Math.round(averageRating * 10) / 10, // Use freshly calculated value
          dateAdded: d.created_at,
        };
      }).filter(Boolean);
    };
     
    // --- THE FIX: The query is now much more efficient ---
    // It no longer fetches the full dish_comments or dish_photos tables.
    // It only fetches the 'rating' column from dish_ratings to calculate the average.
    let query = supabaseAdminClient
      .from('restaurant_dishes')
      .select(\`
        *,
        restaurants!inner(id, name, latitude, longitude),
        dish_ratings(rating)
      \`)
      .eq('is_active', true)
      .not('restaurants.latitude', 'is', null);


    const term = searchTerm?.trim();
    if (term && term.length > 1) {
      const allSearchTerms = new Set<string>();
      const exclusionTerms = new Set<string>();
     
      const isCategory = checkCategorySearch(term);
     
      const needsContextFiltering = term.toLowerCase() === 'roll' || term.toLowerCase() === 'rolls' || term.toLowerCase() === 'bakery';
     
      const synonymTerms = getAllRelatedTerms(term, needsContextFiltering || term.toLowerCase() === 'bakery');
      synonymTerms.forEach(t => allSearchTerms.add(t));
     
      if (isCategory) {
        const categoryTerms = getCategoryTerms(term);
        categoryTerms.forEach(t => allSearchTerms.add(t));
      }
     
      if (needsContextFiltering || isCategory) {
        const excludeTerms = getExclusionTerms(term, allSearchTerms);
        excludeTerms.forEach(t => exclusionTerms.add(t));
      }
     
      const finalSearchTerms = Array.from(allSearchTerms).slice(0, 100);
     
      if (finalSearchTerms.length > 0) {
        const orFilter = finalSearchTerms
          .map((t: string) => \`name.ilike.%\${t.replace(/%/g, '\\\\%').replace(/_/g, '\\\\_')}%\`)
          .join(',');
       
        query = query.or(orFilter);
       
        if (exclusionTerms.size > 0) {
          Array.from(exclusionTerms).forEach(excludeTerm => {
            query = query.not('name', 'ilike', \`%\${excludeTerm}%\`);
          });
        }
      }
    }


    if (minRating && minRating > 0) {
      query = query.gte('average_rating', minRating);
    }


    query = query.order('average_rating', { ascending: false }).limit(200);


    const { data, error } = await query;
    if (error) throw error;
     
    const results = processRawDishes(data || []);


    return new Response(JSON.stringify(results), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    })
  } catch (error) {
    console.error('[EDGE FUNCTION ERROR]', error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
})`,

    'get-menu-data': `// supabase/functions/get-menu-data/index.ts
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface RawDishData {
  id: string;
  name: string;
  description?: string;
  dish_ratings?: Array<{
    rating: number;
    user_id: string;
  }>;
  dish_comments?: Array<{
    id: string;
    comment_text: string;
    created_at: string;
    is_hidden?: boolean;
    users?: {
      full_name?: string;
      email?: string;
    };
  }>;
  dish_photos?: Array<{
    id: string;
    storage_path: string;
    caption?: string;
    created_at: string;
    users?: {
      full_name?: string;
      email?: string;
    };
  }>;
  [key: string]: unknown;
}

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
};

const supabaseAdminClient = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

const securityCheck = async (req: Request, supabaseUrl: string, supabaseAnonKey: string): Promise<{ user: unknown; error: string | null }> => {
  const authHeader = req.headers.get('Authorization');
  if (!authHeader) {
    return { user: null, error: 'Missing Authorization header.' };
  }
   
  try {
    const userClient = createClient(supabaseUrl, supabaseAnonKey, {
      global: { headers: { Authorization: authHeader } },
    });
     
    const { data: { user } } = await userClient.auth.getUser();
    if (!user) {
      return { user: null, error: 'Invalid token.' };
    }

    return { user, error: null };

  } catch {
      return { user: null, error: 'An error occurred during authentication.' };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // --- SECURITY CHECK ---  
    const { error: authError } = await securityCheck(req, Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_ANON_KEY')!);
    if (authError) {
      return new Response(JSON.stringify({ error: authError }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const { restaurantId } = await req.json();

    if (!restaurantId) {
      throw new Error('Missing restaurantId in request body.');
    }
    
    // This is the exact query logic from the useDishes hook, now running on the server.
    // Added back the ordering for consistency.
    const { data, error } = await supabaseAdminClient
      .from('restaurant_dishes')
      .select(\`
        *,
        dish_ratings (*),
        dish_comments!left (
          *,
          users!dish_comments_user_id_fkey (
            full_name,
            email
          )
        ),
        dish_photos!left (
          *,
          users!dish_photos_user_id_fkey (
            full_name,
            email
          )
        )
      \`)
      .eq('restaurant_id', restaurantId)
      .eq('is_active', true)
      .order('created_at', { ascending: true });

    if (error) {
      throw error;
    }

    // Apply the same processing that was in the client
    const processedDishes = (data || []).map((dish: RawDishData) => {
      const ratings = dish.dish_ratings as Array<{ rating: number; user_id: string; }> || [];
      const totalRatings = ratings.length;
      const averageRating = totalRatings > 0
        ? ratings.reduce((sum, r) => sum + r.rating, 0) / totalRatings
        : 0;

      const comments = (dish.dish_comments as any[] || [])
        .filter((comment: any) => comment.is_hidden !== true)
        .map((comment: any) => ({
          ...comment,
          commenter_name: comment.users?.full_name || 'Anonymous User',
          commenter_email: comment.users?.email,
        }));

      const photos = (dish.dish_photos as any[] || [])
        .map((photo: any) => ({
          ...photo,
          photographer_name: photo.users?.full_name || 'Anonymous User',
          photographer_email: photo.users?.email,
        }));

      return {
        ...dish,
        ratings,
        comments,
        photos,
        total_ratings: totalRatings,
        average_rating: Math.round(averageRating * 10) / 10,
      };
    });

    return new Response(JSON.stringify(processedDishes), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error) {
    console.error('[GET-MENU-DATA ERROR]', error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
})`,

    'geoapify-proxy': `// supabase/functions/geoapify-proxy/index.ts
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// CORS headers for browser access  
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
}

const securityCheck = async (req: Request, supabaseUrl: string, supabaseAnonKey: string): Promise<{ user: unknown; error: string | null }> => {
  const authHeader = req.headers.get('Authorization');
  if (!authHeader) {
    return { user: null, error: 'Missing Authorization header.' };
  }
   
  try {
    const userClient = createClient(supabaseUrl, supabaseAnonKey, {
      global: { headers: { Authorization: authHeader } },
    });
     
    const { data: { user } } = await userClient.auth.getUser();
    if (!user) {
      return { user: null, error: 'Invalid token.' };
    }

    return { user, error: null };

  } catch {
      return { user: null, error: 'An error occurred during authentication.' };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // --- SECURITY CHECK ---  
    const { error: authError } = await securityCheck(req, Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_ANON_KEY')!);
    if (authError) {
      return new Response(JSON.stringify({ error: authError }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { categories, longitude, latitude, radiusInMeters, bias, limit } = await req.json();

    // Validate required parameters
    if (!longitude || !latitude || !radiusInMeters) {
      return new Response(JSON.stringify({ error: 'Missing required parameters: longitude, latitude, radiusInMeters' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Get API key from environment variables (server-side only)
    const apiKey = Deno.env.get('GEOAPIFY_API_KEY');
    if (!apiKey) {
      return new Response(JSON.stringify({ error: 'Geoapify API key not configured' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Build the Geoapify API URL
    const baseUrl = 'https://api.geoapify.com/v2/places';
    const params = new URLSearchParams({
      categories: categories || 'catering.restaurant,catering.cafe,catering.fast_food,catering.bar,catering.pub',
      filter: \`circle:\${longitude},\${latitude},\${radiusInMeters}\`,
      bias: bias || \`proximity:\${longitude},\${latitude}\`,
      limit: (limit || 50).toString(),
      apiKey: apiKey
    });

    const geoapifyUrl = \`\${baseUrl}?\${params.toString()}\`;

    // Make the request to Geoapify API
    const response = await fetch(geoapifyUrl);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'API response was not valid JSON.' }));
      return new Response(JSON.stringify({ 
        error: \`Geoapify API failed with status \${response.status}: \${errorData.message || 'Unknown error'}\` 
      }), {
        status: response.status,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const data = await response.json();
    
    return new Response(JSON.stringify(data), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error) {
    console.error('[GEOAPIFY-PROXY ERROR]', error);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
})`
};

function log(message) {
    const logElement = document.getElementById('deploymentLog');
    const timestamp = new Date().toLocaleTimeString();
    logElement.textContent += `[${timestamp}] ${message}\n`;
    logElement.scrollTop = logElement.scrollHeight;
}

function clearLog() {
    document.getElementById('deploymentLog').textContent = 'Log cleared...\n';
}

async function validateToken() {
    const tokenInput = document.getElementById('accessToken');
    const statusDiv = document.getElementById('tokenStatus');
    accessToken = tokenInput.value.trim();
    
    if (!accessToken) {
        statusDiv.innerHTML = '<span class="error">Please enter an access token</span>';
        return;
    }
    
    log('Validating access token...');
    statusDiv.innerHTML = 'Validating...';
    
    try {
        const response = await fetch(\`https://api.supabase.com/v1/projects/\${PROJECT_REF}\`, {
            headers: {
                'Authorization': \`Bearer \${accessToken}\`
            }
        });
        
        if (response.ok) {
            statusDiv.innerHTML = '<span class="success">‚úÖ Token validated successfully!</span>';
            log('‚úÖ Access token validated');
            
            // Enable deployment buttons
            document.getElementById('deployDishSearch').disabled = false;
            document.getElementById('deployGetMenu').disabled = false;
            document.getElementById('deployGeoapify').disabled = false;
            document.getElementById('deployAll').disabled = false;
        } else {
            throw new Error(\`HTTP \${response.status}\`);
        }
    } catch (error) {
        statusDiv.innerHTML = \`<span class="error">‚ùå Invalid token: \${error.message}</span>\`;
        log(\`‚ùå Token validation failed: \${error.message}\`);
    }
}

async function deployFunction(functionName) {
    if (!accessToken) {
        log('‚ùå Please validate your access token first');
        return;
    }
    
    const functionCode = FUNCTIONS[functionName];
    if (!functionCode) {
        log(\`‚ùå Function code not found: \${functionName}\`);
        return;
    }
    
    log(\`üöÄ Deploying function: \${functionName}\`);
    
    try {
        const response = await fetch(\`https://api.supabase.com/v1/projects/\${PROJECT_REF}/functions/\${functionName}\`, {
            method: 'POST',
            headers: {
                'Authorization': \`Bearer \${accessToken}\`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                slug: functionName,
                source: functionCode,
                verify_jwt: false
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(\`HTTP \${response.status}: \${errorText}\`);
        }
        
        const result = await response.json();
        log(\`‚úÖ Successfully deployed: \${functionName}\`);
        
    } catch (error) {
        log(\`‚ùå Failed to deploy \${functionName}: \${error.message}\`);
        throw error;
    }
}

async function deployAllFunctions() {
    log('üîÑ Starting deployment of all functions...');
    
    for (const functionName of Object.keys(FUNCTIONS)) {
        try {
            await deployFunction(functionName);
            // Small delay between deployments
            await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
            log('üõë Stopping deployment due to error');
            return;
        }
    }
    
    log('üéâ All functions deployed successfully!');
    log('üìã Next: Test your app to verify CORS errors are resolved');
}

function showFunctionCode() {
    const select = document.getElementById('functionSelect');
    const preview = document.getElementById('functionPreview');
    
    if (select.value) {
        preview.textContent = FUNCTIONS[select.value];
        preview.style.display = 'block';
    } else {
        preview.style.display = 'none';
    }
}
</script>
</body>
</html>